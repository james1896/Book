iOS，一行代码进行RSA、DES 、AES加密、解密及MD5加密
http://www.jianshu.com/p/8fd8306a95d0


144  作者 AimLay 关注
2016.04.09 13:27* 字数 1350 阅读 14461评论 77喜欢 437
更新：MD5加密是单向的，只能加密不能解密(破解除外)。标题可能会引起读者误解，已经改正，感谢Li_Cheng同学的提醒，另外笔者发现Li_Cheng同学有篇MD5加密更为详尽的文章，推荐阅读:iOS开发 关于MD5加密的相关使用
加密的Demo，欢迎下载

java端的加密解密，读者可以看我同事的这篇文章http://www.jianshu.com/p/98569e81cc0b

最近做了一个移动项目，是有服务器和客户端类型的项目，客户端是要登录才行的，服务器也会返回数据，服务器是用Java开发的，客户端要同时支持多平台（Android、iOS），在处理iOS的数据加密的时候遇到了一些问题。起初采取的方案是DES加密，老大说DES加密是对称的，网络抓包加上反编译可能会被破解，故采取RSA方式加密。RSA加密时需要公钥和私钥，客户端保存公钥加密数据，服务器保存私钥解密数据。（iOS端公钥加密私钥解密、java端公钥加密私钥解密，java端私钥加密公钥解密都容易做到，iOS不能私钥加密公钥解密，只能用于验签）。

问题

问题1：iOS端公钥加密的数据用Java端私钥解密。

iOS无论使用系统自带的sdk函数，用mac产生的或者使用java的jdk产生的公钥和私钥，进行加密解密自己都可以使用。不过ios加密，java解密，或者反过来就不能用了。要么是无法创建报告个-9809或-50的错误，要么解出来是乱码。ios系统函数种只有用公钥加密，私钥解密的方式。而公钥加密每次结果都不同。

MAC上生成公钥、私钥的方法，及使用
1.打开终端，切换到自己想输出的文件夹下
2.输入指令:openssl（openssl是生成各种秘钥的工具，mac已经嵌入
3.输入指令:genrsa -out rsa_private_key.pem 1024 (生成私钥，java端使用的)
4.输入指令:rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout (生成公钥)
5.输入指令:pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem     -nocrypt(私钥转格式，在ios端使用私钥解密时用这个私钥)
注意:在MAC上生成三个.pem格式的文件，一个公钥，两个私钥，都可以在终端通过指令vim xxx.pem 打开，里面是字符串，第三步生成的私钥是java端用来解密数据的，第五步转换格式的私钥iOS端可以用来调试公钥、私钥解密（因为私钥不留在客户端）
详细步骤
问题2：服务器返回数据也要加密，老大打算用java私钥加密,ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。

通过看一些大牛的介绍，了解了iOS常用的加密方式
1 通过简单的URLENCODE ＋ BASE64编码防止数据明文传输
2 对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验
3 对于重要数据，使用RSA进行数字签名，起到防篡改作
4 对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密
原因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；如果使用DES的话，可以通过破解客户端获取密钥，安全性较低。而服务器返回之所以使用DES，是因为不管使用DES还是RSA，密钥（或私钥）都存储在客户端，都存在被破解的风险，因此，需要采用动态密钥，而RSA的密钥生成比较复杂，不太适合动态密钥，并且RSA速度相对较慢，所以选用DES）
所以此次加密，我们选择了第四种加密方式
加密方式

ios端进行DES加密、解密时非常方便

1、引入头文件 #import "DES3Util.h"
2、加密时调用类方法  +(NSString *) encryptUseDES:(NSString *)plainText key:(NSString *)key;
3、解密时调用类方法  +(NSString *)decryptUseDES:(NSString *)cipherText key:(NSString *)key;
ios端进行RSA加密、解密时非常方便

1、引入头文件 #import "RSAUtil.h"
2、公钥加密时调用类方法：
+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;
+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey;
3、私钥解密时调用类方法 
+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;
+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey;
ios端进行MD5加密、解密时非常方便

1、引入头文件 #import "MD5Util"
2、加密时调用方法：- (NSString *)md5:(NSString *)str;
ios端进行AES加密、解密时非常方便

1、引入头文件 #import "AES.h"
2、加密时调用方法
+ (NSString *)encrypt:(NSString *)message password:(NSString *)password;
2、解密时调用的方法
+ (NSString *)decrypt:(NSString *)base64EncodedString password:(NSString *)password;
有关RSA、MD5、AES加密的原理介绍

效果图


Encryption.gif
 iOS网络请求 © 著作权归作者所有 举报文章
144 关注AimLay 
写了 20290 字，被 679 人关注，获得了 1115 个喜欢
专注、追求、自省、不忘初心
如果觉得我的文章对您有用，请随意赞赏。您的支持将鼓励我继续创作！

赞赏支持

喜欢 437    更多分享
登录 后发表评论
77条评论 只看作者 按喜欢排序按时间正序按时间倒序
 Ian_He
6楼 · 2016.04.10 17:32
认证阶段使用非对称密码系统, 认证结束后动态生成只有客户端和服务端掌握的对称密码进行加密, 这样比较有效率. 全部用非对称的计算量想必很头疼.

非对称密码界没有私钥加密的说法, 私钥只能用来生成签名和解密, 公钥只能验签和加密, 这是基本概念, 不是iOS不支持. 网络上太多人混淆了这个概念, 才会出现私钥加密的说法, 导致后来的人学习的时候很困惑.

 4人赞  回复
AimLay： @Ian_He 又get到了好多新知识，有个问题，认证阶段用非对称的加密系统，加密的应该是什么信息呢？用户名和密码？认证结束后，使用动态生成的客户端和服务端掌握的对称密码，如果对称密码破解了，那么这次网络请求的信息不就被拿到了？？
2016.04.10 17:43  回复
Ian_He： @Flying_Einstein 加密经过哈希的用户密码, 服务端存用户密码的哈希值. 认证过程中, 客户端和服务器可以用diffie-hellman密钥交换协议协商密钥, 这个迷药第三方是无法在有效时间内破解.
2016.04.10 18:03  回复
AimLay： @Ian_He 看的我一脸懵逼，确实不懂，我只是实现了这个需求，更深层次的东西理解的不多，不过仍旧谢谢你，有空了研究一下数据安全的东西








iOS RSA的网络安全模型、iOS签名机制总结（登录、token安全、签名）
http://www.jianshu.com/p/2927ca2b3719

144  作者 Peak_One 关注
2016.03.20 12:41 字数 2787 阅读 7330评论 49喜欢 154
摘要

最近公司准备做一个安全级别比较高的项目：技术总监给我们提出了一个这样子的需求:在http请求过程中，即使嗅探器捕获到网络请求的链接也无法去请求到数据。经过一番思考，觉得支付宝的签名完全符合这样子的需求。但是之前自己对签名、RSA等知识也是知道的很少，所以花了一番功夫学习了一下。本文将针对RSA登录和http请求作讲解，希望对大家有所帮助。

一.登录、登录保持（http请求）

登录机制

登录机制大概可以分为一下三个阶段：

1. 登录验证：是指客户端提供用户名和密码，向服务器提出登录请求，服务器判断客户端是否可以登录并向客户端确认。
2. 登录保持：是指客户端登录后， 服务器能够分辨出已登录的客户端，并为其持续提供登录权限的服务器。
3. 登出：是指客户端主动退出登录状态。
第一种网络请求情况（安全级别：II）

一般的情况是这个样子的：一但用户登陆成功（单方面MD5加密：服务器加密则客户端不加密，客户端加密则明文传输），服务器为客户端分配sessionID(也可以称为userID),当然有些服务器不但为客户端分配了userID还有可能会为用户提供token了(这个下面会做解释)，然后每次网络请求都将sessionID当做参数传递给服务器。

优点

能够保持用户登录状态、区分用户，相对于不返回任何信息的登录要安全了一些。

缺点

如果通过网络嗅探器（例如：青花瓷）可以获取到http链接，这样子服务器返回的sessionID便会被获取到，这样子依然会造成信息泄露，并且还能被伪造请求（浏览器请求）。

第二种网络请求情况 （安全级别：III）

第一种存在明显的安全隐患，但是目前市面上的好多app依然采用第一种方法去实现登录、网络请求，但是对于安全级别较高的app，已经不再适用了。所以在此基础上进行优化----采用非对称加密（公钥、私钥）。

登录模型

客户端第一次发出登录请求时， 用户密码以明文的方式传输， 一旦被截获， 后果严重。因此密码需要加密，例如可采用RSA非对称加密。具体流程如下：

客户端向服务器第一次发起登录请求（不传输用户名和密码）。
服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。
客户端收到公钥后， 加密用户密码， 向服务器发起第二次登录请求（传输用户名和加密后的密码）。
服务器利用保留的私钥对密文进行解密，得到真正的密码。
第三种网络请求情况（安全级别：IIII）

再仔细核对上述登录流程， 我们发现服务器判断用户是否登录， 完全依赖于sessionId, 一旦其被截获， 黑客就能够模拟出用户的请求。于是我们需要引入token的概念： 用户登录成功后， 服务器不但为其分配了sessionId, 还分配了token， token是维持登录状态的关键秘密数据。在服务器向客户端发送的token数据，也需要加密。于是一次登录的细节再次扩展。

客户端向服务器第一次发起登录请求（不传输用户名和密码）。
服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。
客户端收到公钥后， 加密用户密码，向服务器发送用户名和加密后的用户密码； 同时另外产生一对公钥和私钥，自己保留私钥, 向服务器发送公钥； 于是第二次登录请求传输了用户名和加密后的密码以及客户端生成的公钥。
服务器利用保留的私钥对密文进行解密，得到真正的密码。 经过判断， 确定用户可以登录后，生成sessionId和token， 同时利用客户端发送的公钥，对token进行加密。最后将sessionId和加密后的token返还给客户端。
客户端利用自己生成的私钥对token密文解密， 得到真正的token。
图示如下：


login-300x181.png
登录保持（也就是http数据请求阶段）

引入token后，http请求被获取问题便可得到解决。 服务器将token和其它的一些变量， 利用散列加密算法得到签名后，连同sessionId一并发送给服务器； 服务器取出保存于服务器端的token,利用相同的法则生成校验签名， 如果客户端签名与服务器的校验签名一致， 就认为请求来自登录的客户端。（支付宝一样的机制）
结构图如下：


keep_login.png

注：token失效的两种情况：

  1. 用户登录出系统
  2. token在后台的规定时间内失效（每个token都是有时间效应的）
失效原理：
在服务器端的redis中删除相应key为session的键值对。

二.散列算法

散列是信息的提炼，通常其长度要比信息小得多，且为一个固定长度。加密性强的散列一定是不可逆的，这就意味着通过散列结果，无法推出任何部分的原始信息。任何输入信息的变化，哪怕仅一位，都将导致散列结果的明显变化，这称之为雪崩效应。散列还应该是防冲突的，即找不出具有相同散列结果的两条信息。具有这些特性的散列结果就可以用于验证信息是否被修改。

散列算法可以用来加密token生成签名， 以便token信息不暴露在网络同时还能验证登录的有效性。

MD5

全写： Message Digest Algorithm MD5（中文名为消息摘要算法第五版）
输出： 128bit

MD5算法具有以下特点：

1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。
2、容易计算：从原数据计算出MD5值很容易。
3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。
缺陷：Md5一度被认为十分靠谱。2004年8月17日的美国加州圣巴巴拉的国际密码学会议（Crypto’2004）上，来自中国山东大学的王小云教授做了破译MD5、HAVAL-128、 MD4和RIPEMD算法的报告，公布了MD系列算法的破解结果。2009年，冯登国、谢涛二人利用差分攻击，将MD5的碰撞算法复杂度从王小云的2^42进一步降低到2^21，极端情况下甚至可以降低至2^10。仅仅2^21的复杂度意味着即便是在2008年的计算机上，也只要几秒便可以找到一对碰撞。Md5已老， 在安全性要求较高的场合，不建议使用。

SHA1

全名： 安全哈希算法（Secure Hash Algorithm）输出： 160bit
与Md5比较
相同点：因为二者均由MD4导出，SHA-1和MD5彼此很相似。相应的，他们的强度和其他特性也是相似。不同点：1. 对强行攻击的安全性：最显著和最重要的区别是SHA-1摘要比MD5摘要长32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是2^128数量级的操作，而对SHA-1则是2^160数量级的操作。这样，SHA-1对强行攻击有更大的强度。2. 对密码分析的安全性：由于MD5的设计，易受密码分析的攻击，SHA-1显得不易受这样的攻击。3. 速度：在相同的硬件上，SHA-1的运行速度比MD5慢。

加盐

所谓加盐， 就是在原本需要加密的信息基础上，糅入其它内容salt。签名的生成就是一次加盐。

对称加密

本系统使用对称加密对用户密码进行加密以及生成token字符串。
AuthCode加密
AuthCode是康盛科技发明的加密方式， 开源产品Discuz的密码是用这个算法进行加密。但是有点遗憾，这个函数所有权属于康盛创想，并不能自由使用的。不知使用是否有风险？？
AES加密
高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。

非对称加密

RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。
算法描述：
（1）选择一对不同的、足够大的素数p，q。
（2）计算n=pq。
（3）计算f(n)=(p-1)(q-1)，同时对p, q严加保密，不让任何人知道。
（4）找一个与f(n)互质的数e（公钥指数），且1<e<f(n)。
（5）计算d（私钥指数），使得de≡1 mod f(n)。这个公式也可以表达为d ≡e-1 mod f(n)注，≡是数论中表示同余的符号。
（6）公钥KU=(e,n)，私钥KR=(d,n)。
（7）加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为：



（8）解密过程为：

